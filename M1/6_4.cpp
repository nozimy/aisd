//
// Created by nozim on 20.03.19.
//

/**
 *
 * Даны неотрицательные целые числа n,k и массив целых чисел из [0..10^9]
 * размера n. Требуется найти k-ю порядковую статистику. т.е. напечатать
 * число, которое бы стояло на позиции с индексом k (0..n-1) в отсортированном
 * массиве. Напишите нерекурсивный алгоритм.
 * Требования к дополнительной памяти: O(n). Требуемое среднее время работы: O(n).
 * Функцию Partition следует реализовывать методом прохода двумя итераторами в
 * одном направлении. Описание для случая прохода от начала массива к концу:
 *      - Выбирается опорный элемент. Опорный элемент меняется с последним
 *      элементом массива.
 *      - Во время работы Partition в начале массива содержатся элементы,
 *      не бОльшие опорного. Затем располагаются элементы, строго бОльшие опорного.
 *      - В конце массива лежат нерассмотренные элементы. Последним элементом лежит опорный.
 *      - Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
 *      - Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
 *      - Шаг алгоритма. Рассматривается элемент, на который указывает j. Если он больше опорного,
 *      то сдвигаем j.
 *      - Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
 *      - В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.
 *
 *
 *      ИЗ:
 *      6_4. Реализуйте стратегию выбора опорного элемента “случайный элемент”.
 *      Функцию Partition реализуйте методом прохода двумя итераторами от конца массива к началу.
 *
 */

#include <iostream>
#include <ctime>
#include <cstdlib>
using namespace std;

int partition(int *arr, int left, int right);
int order_statistic(int *arr, int n, int k);

int main(){
    int n, k;
    cin >> n >> k;
    int *arr = new int[n];
    int i = 0;
    for (i=0; i < n; i++) {
        cin >> arr[i];
    }

    cout << order_statistic(arr, n, k) << endl;

    delete[] arr;
    return 0;
}

// Возвращает индекс, на который встанет пивот после разделения.
int partition(int *arr, int left, int right){
    if (right - left <= 1) {
        return left;
    }

    srand(time(0));
    int r = (rand() % (right - 1 - left + 1) + left);
    swap(arr[r], arr[left]);
    const int& pivot = arr[left];

    int i = right-1, j = right-1;
    while(i > left){
        for(;arr[i] < pivot; --i) {}
        if (i>left){
            swap(arr[i--], arr[j--]);
        }
    }
    swap(arr[j], arr[left]);
    return j;
}

int order_statistic(int * arr, int n, int k) {
    int left = 0, right = n;

    while(left < right){
        int part = partition(arr, left, right);
        if (part == k) {
            return arr[part];
        }
        else if (k < part) {
            right = part;
        }
        else {
            left = part + 1;
        }
    }
}
